#pragma once

static const char *kParticlesVS =
    "#version 330 core\n"
    "layout(location=0) in vec3 aPos;\n"
    "layout(location=1) in float aRadius;\n"
    "layout(location=2) in vec3 aColor;\n"
    "layout(location=3) in uint aLayer;\n"
    "layout(location=4) in vec3 aSpin;\n"
    "uniform mat4 uWorldToClip;\n"
    "uniform vec3 uCamRight;\n"
    "uniform vec3 uCamUp;\n"
    "out vec3 vColor;\n"
    "flat out uint vLayer;\n"
    "flat out vec3 vSpin;\n"
    "out vec2 vLocal;\n"
    "void main(){\n"
    "  vec2 corner;\n"
    "  if (gl_VertexID == 0) corner = vec2(-1.0, -1.0);\n"
    "  else if (gl_VertexID == 1) corner = vec2( 1.0, -1.0);\n"
    "  else if (gl_VertexID == 2) corner = vec2(-1.0,  1.0);\n"
    "  else corner = vec2( 1.0,  1.0);\n"
    "  vLocal = corner;\n"
    "  vec3 worldPos = aPos + (uCamRight * (corner.x * aRadius)) + (uCamUp * (corner.y * aRadius));\n"
    "  gl_Position = uWorldToClip * vec4(worldPos, 1.0);\n"
    "  vColor = aColor;\n"
    "  vLayer = aLayer;\n"
    "  vSpin = aSpin;\n"
    "}\n";

static const char *kParticlesFS =
    "#version 330 core\n"
    "in vec3 vColor;\n"
    "flat in uint vLayer;\n"
    "flat in vec3 vSpin;\n"
    "in vec2 vLocal;\n"
    "uniform sampler2DArray uTex;\n"
    "uniform float uTime;\n"
    "out vec4 oColor;\n"
    "void main(){\n"
    "  vec2 p = vLocal;\n"
    "  float r2 = dot(p, p);\n"
    "  if (r2 > 1.0) discard;\n"
    "  vec3 n = normalize(vec3(p, sqrt(max(0.0, 1.0 - r2))));\n"
    "  float tilt = vSpin.x;\n"
    "  float spin_rate = vSpin.y;\n"
    "  float spin0 = vSpin.z;\n"
    "  float ang = uTime * spin_rate + spin0;\n"
    "  vec3 axis = normalize(vec3(0.0, cos(tilt), sin(tilt)));\n"
    "  // Rodrigues rotation: rotate local normal around spin axis\n"
    "  vec3 n2 = n * cos(ang) + cross(axis, n) * sin(ang) + axis * dot(axis, n) * (1.0 - cos(ang));\n"
    "  float lon = atan(n2.z, n2.x);\n"
    "  float lat = asin(clamp(n2.y, -1.0, 1.0));\n"
    "  vec2 uv = vec2(0.5 + lon / (2.0 * 3.14159265), 0.5 - lat / 3.14159265);\n"
    "  vec3 l = normalize(vec3(-0.4, 0.6, 0.7));\n"
    "  float diff = clamp(dot(n, l) * 0.7 + 0.35, 0.0, 1.0);\n"
    "  vec4 tex = texture(uTex, vec3(uv, float(vLayer)));\n"
    "  float edge = smoothstep(1.0, 0.85, r2);\n"
    "  vec3 rgb = tex.rgb * vColor * diff;\n"
    "  oColor = vec4(rgb, tex.a * edge);\n"
    "}\n";

static const char *kLinesVS =
    "#version 330 core\n"
    "layout(location=0) in vec3 aPos;\n"
    "layout(location=1) in vec4 aColor;\n"
    "uniform mat4 uWorldToClip;\n"
    "out vec4 vColor;\n"
    "void main(){\n"
    "  gl_Position = uWorldToClip * vec4(aPos, 1.0);\n"
    "  vColor = aColor;\n"
    "}\n";

static const char *kLinesFS =
    "#version 330 core\n"
    "in vec4 vColor;\n"
    "out vec4 oColor;\n"
    "void main(){\n"
    "  oColor = vColor;\n"
    "}\n";

static const char *kBgVS =
    "#version 330 core\n"
    "out vec2 vUv;\n"
    "void main(){\n"
    "  vec2 p;\n"
    "  if (gl_VertexID == 0) p = vec2(-1.0, -1.0);\n"
    "  else if (gl_VertexID == 1) p = vec2(3.0, -1.0);\n"
    "  else p = vec2(-1.0, 3.0);\n"
    "  gl_Position = vec4(p, 0.0, 1.0);\n"
    "  vUv = p * 0.5 + 0.5;\n"
    "}\n";

static const char *kBgFS =
    "#version 330 core\n"
    "in vec2 vUv;\n"
    "out vec4 oColor;\n"
    "uniform sampler2D uEnv;\n"
    "uniform int uHasEnv;\n"
    "uniform mat3 uInvViewRot;\n"
    "uniform float uAspect;\n"
    "uniform float uExposure;\n"
    "\n"
    "float hash13(vec3 p){\n"
    "  p = fract(p * 0.1031);\n"
    "  p += dot(p, p.yzx + 33.33);\n"
    "  return fract((p.x + p.y) * p.z);\n"
    "}\n"
    "\n"
    "vec3 procedural_stars(vec3 dir){\n"
    "  float n = hash13(dir * 123.4);\n"
    "  float star = smoothstep(0.9995, 1.0, n);\n"
    "  float n2 = hash13(dir * 971.7 + 5.1);\n"
    "  float star2 = smoothstep(0.99985, 1.0, n2) * 2.0;\n"
    "  float band = pow(1.0 - abs(dir.y), 6.0) * 0.08;\n"
    "  vec3 c = vec3(0.8, 0.9, 1.0) * star * 1.8 + vec3(1.0, 0.85, 0.7) * star2 * 2.5;\n"
    "  c += band * vec3(0.2, 0.25, 0.35);\n"
    "  return c;\n"
    "}\n"
    "\n"
    "vec2 dir_to_equirect(vec3 d){\n"
    "  float lon = atan(d.z, d.x);\n"
    "  float lat = asin(clamp(d.y, -1.0, 1.0));\n"
    "  return vec2(0.5 + lon / (2.0 * 3.14159265), 0.5 - lat / 3.14159265);\n"
    "}\n"
    "\n"
    "void main(){\n"
    "  // Simple view ray with a fixed vertical FOV.\n"
    "  vec2 ndc = vUv * 2.0 - 1.0;\n"
    "  float fovY = 1.1;\n"
    "  vec3 dirV = normalize(vec3(ndc.x * uAspect, ndc.y, 1.0 / tan(fovY * 0.5)));\n"
    "  vec3 dirW = normalize(uInvViewRot * dirV);\n"
    "  vec3 col = vec3(0.0);\n"
    "  if (uHasEnv == 1) {\n"
    "    vec2 uv = dir_to_equirect(dirW);\n"
    "    col += texture(uEnv, uv).rgb;\n"
    "  }\n"
    "  col += procedural_stars(dirW);\n"
    "  col *= uExposure;\n"
    "  // Tone-map + gamma.\n"
    "  col = col / (col + vec3(1.0));\n"
    "  col = pow(col, vec3(1.0/2.2));\n"
    "  oColor = vec4(col, 1.0);\n"
    "}\n";

static const char *kTextVS =
    "#version 330 core\n"
    "layout(location=0) in vec2 aPosPx;\n"
    "layout(location=1) in vec2 aUv;\n"
    "uniform vec2 uViewport;\n"
    "uniform vec2 uOffsetPx;\n"
    "out vec2 vUv;\n"
    "void main(){\n"
    "  vec2 p = aPosPx + uOffsetPx;\n"
    "  vec2 ndc = vec2((p.x / uViewport.x) * 2.0 - 1.0, 1.0 - (p.y / uViewport.y) * 2.0);\n"
    "  gl_Position = vec4(ndc, 0.0, 1.0);\n"
    "  vUv = aUv;\n"
    "}\n";

static const char *kTextFS =
    "#version 330 core\n"
    "in vec2 vUv;\n"
    "out vec4 oColor;\n"
    "uniform sampler2D uFont;\n"
    "uniform vec4 uColor;\n"
    "void main(){\n"
    "  float a = texture(uFont, vUv).r;\n"
    "  if (a < 0.5) discard;\n"
    "  oColor = vec4(uColor.rgb, uColor.a);\n"
    "}\n";
